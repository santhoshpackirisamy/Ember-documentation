1) Unit Tests

Unit Tests are useful for testing pure functions where the return value is only determined by its input values, without any observable side effects.

2) Container Tests

If we need to test the functionality around an Ember class instance, such as a Controller, Service, or Route, we can use a container test to do that by setting up the application's container.

3) Rendering Tests

If we need to test the interactions between various parts of the application, such as behavior between UI controls we can utilize Rendering Tests.

4) Application Tests

Finally if we are looking to test user interaction and application flow in order to verify user stories or a feature from an end-user perspective, we can use Application Tests. In these kinds of tests, we interact with the application in the same ways that a user would, such as filling out form fields and clicking buttons.

5) Application Tests

*) setupApplicationTest deals with application setup and teardown

*) Types:

    *) Asynchronous Helpers

Asynchronous helpers are "aware" of (and wait for) asynchronous behavior within your application, making it much easier to write deterministic tests.

    *) Synchronous Helpers

Synchronous helpers are performed immediately when triggered.


6) Testing Basics

    *) By testing the basics properties of computation.
    
    *) Some times you might be working on a feature, but know that a certain test will fail so you might want to skip it. You can do it by using skip:

        import { test, skip } from 'qunit';

        test('run this test', function(assert) {
            assert.ok(true)
        });

        skip('skip this test', function(assert) {
            assert.ok(true)
        });
        
